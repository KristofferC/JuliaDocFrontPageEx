<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Release Notes · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li class="current"><a class="toctext" href="NEWS.html">Release Notes</a><ul class="internal"><li><a class="toctext" href="#New-language-features-1">New language features</a></li><li><a class="toctext" href="#Language-changes-1">Language changes</a></li><li><a class="toctext" href="#Breaking-changes-1">Breaking changes</a></li><li><a class="toctext" href="#Library-improvements-1">Library improvements</a></li><li><a class="toctext" href="#Compiler/Runtime-improvements-1">Compiler/Runtime improvements</a></li><li><a class="toctext" href="#Deprecated-or-removed-1">Deprecated or removed</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="manual/introduction.html">Introduction</a></li><li><a class="toctext" href="manual/getting-started.html">Getting Started</a></li><li><a class="toctext" href="manual/variables.html">Variables</a></li><li><a class="toctext" href="manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="manual/strings.html">Strings</a></li><li><a class="toctext" href="manual/functions.html">Functions</a></li><li><a class="toctext" href="manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="manual/types.html">Types</a></li><li><a class="toctext" href="manual/methods.html">Methods</a></li><li><a class="toctext" href="manual/constructors.html">Constructors</a></li><li><a class="toctext" href="manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="manual/modules.html">Modules</a></li><li><a class="toctext" href="manual/documentation.html">Documentation</a></li><li><a class="toctext" href="manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="manual/environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="manual/packages.html">Packages</a></li><li><a class="toctext" href="manual/profile.html">Profiling</a></li><li><a class="toctext" href="manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="manual/workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="manual/unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="stdlib/base.html">Essentials</a></li><li><a class="toctext" href="stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="stdlib/strings.html">Strings</a></li><li><a class="toctext" href="stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="stdlib/constants.html">Constants</a></li><li><a class="toctext" href="stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="stdlib/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="stdlib/test.html">Unit Testing</a></li><li><a class="toctext" href="stdlib/c.html">C Interface</a></li><li><a class="toctext" href="stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="stdlib/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="devdocs/types.html">More about types</a></li><li><a class="toctext" href="devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="NEWS.html">Release Notes</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/2a21f0865581fd8af4b17bc5de9907da9402a820/doc/src/NEWS.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Julia-v0.6.0-Release-Notes-1" href="#Julia-v0.6.0-Release-Notes-1">Julia v0.6.0 Release Notes</a></h1><h2><a class="nav-anchor" id="New-language-features-1" href="#New-language-features-1">New language features</a></h2><ul><li><p>New type system capabilities (<a href="https://github.com/JuliaLang/julia/issues/8974">#8974</a>, <a href="https://github.com/JuliaLang/julia/issues/18457">#18457</a>)</p><ul><li><p>Type parameter constraints can refer to previous parameters, e.g. <code>type Foo{R&lt;:Real, A&lt;:AbstractArray{R}}</code>. Can also be used in method definitions.</p></li><li><p>New syntax <code>Array{T} where T&lt;:Integer</code>, indicating a union of types over all specified values of <code>T</code> (represented by a <code>UnionAll</code> type). This provides behavior similar to parametric methods or <code>typealias</code>, but can be used anywhere a type is accepted. This syntax can also be used in method definitions, e.g. <code>function inv(M::Matrix{T}) where T&lt;:AbstractFloat</code>. Anonymous functions can have type parameters via the syntax <code>((x::Array{T}) where T&lt;:Real) -&gt; 2x</code>.</p></li><li><p>Implicit type parameters, e.g. <code>Vector{&lt;:Real}</code> is equivalent to <code>Vector{T} where T&lt;:Real</code>, and similarly for <code>Vector{&gt;:Int}</code> (<a href="https://github.com/JuliaLang/julia/issues/20414">#20414</a>).</p></li><li><p>Much more accurate subtype and type intersection algorithms. Method sorting and identification of equivalent and ambiguous methods are improved as a result.</p></li></ul></li></ul><h2><a class="nav-anchor" id="Language-changes-1" href="#Language-changes-1">Language changes</a></h2><ul><li><p>&quot;Inner constructor&quot; syntax for parametric types is deprecated. For example, in this definition:</p><pre><code class="language-none">type Foo{T,S&lt;:Real}
    x
    Foo(x) = new(x)
end</code></pre><p>the syntax <code>Foo(x) = new(x)</code> actually defined a constructor for <code>Foo{T,S}</code>, i.e. the case where the type parameters are specified. For clarity, this definition now must be written as <code>Foo{T,S}(x) where {T,S&lt;:Real} = new(x)</code> (<a href="https://github.com/JuliaLang/julia/issues/11310">#11310</a>).</p></li><li><p>The keywords used to define types have changed (<a href="https://github.com/JuliaLang/julia/issues/19157">#19157</a>, <a href="https://github.com/JuliaLang/julia/issues/20418">#20418</a>).</p><ul><li><p><code>immutable</code> changes to <code>struct</code></p></li><li><p><code>type</code> changes to <code>mutable struct</code></p></li><li><p><code>abstract</code> changes to <code>abstract type ... end</code></p></li><li><p><code>bitstype 32 Char</code> changes to <code>primitive type Char 32 end</code></p></li></ul><p>In 0.6, <code>immutable</code> and <code>type</code> are still allowed as synonyms without a deprecation warning.</p></li><li><p>Multi-line and single-line nonstandard command literals have been added. A nonstandard command literal is like a nonstandard string literal, but the syntax uses backquotes (<code>`</code>) instead of double quotes, and the resulting macro called is suffixed with <code>_cmd</code>. For instance, the syntax <code>q`xyz`</code> is equivalent to <code>@q_cmd &quot;xyz&quot;</code> (<a href="https://github.com/JuliaLang/julia/issues/18644">#18644</a>).</p></li><li><p>Nonstandard string and command literals can now be qualified with their module. For instance, <code>Base.r&quot;x&quot;</code> is now parsed as <code>Base.@r_str &quot;x&quot;</code>. Previously, this syntax parsed as an implicit multiplication (<a href="https://github.com/JuliaLang/julia/issues/18690">#18690</a>).</p></li><li><p>For every binary operator <code>⨳</code>, <code>a .⨳ b</code> is now automatically equivalent to the <code>broadcast</code> call <code>(⨳).(a, b)</code>.  Hence, one no longer defines methods for <code>.*</code> etcetera.  This also means that &quot;dot operations&quot; automatically fuse into a single loop, along with other dot calls <code>f.(x)</code> (<a href="https://github.com/JuliaLang/julia/issues/17623">#17623</a>). Similarly for unary operators (<a href="https://github.com/JuliaLang/julia/issues/20249">#20249</a>).</p></li><li><p>Newly defined methods are no longer callable from the same dynamic runtime scope they were defined in (<a href="https://github.com/JuliaLang/julia/issues/17057">#17057</a>).</p></li><li><p><code>isa</code> is now parsed as an infix operator with the same precedence as <code>in</code> (<a href="https://github.com/JuliaLang/julia/issues/19677">#19677</a>).</p></li><li><p><code>@.</code> is now parsed as <code>@__dot__</code>, and can be used to add dots to every function call, operator, and assignment in an expression (<a href="https://github.com/JuliaLang/julia/issues/20321">#20321</a>).</p></li><li><p>The identifier <code>_</code> can be assigned, but accessing its value is deprecated, allowing this syntax to be used in the future for discarding values (<a href="https://github.com/JuliaLang/julia/issues/9343">#9343</a>, <a href="https://github.com/JuliaLang/julia/issues/18251">#18251</a>).</p></li><li><p>The <code>typealias</code> keyword is deprecated, and should be replaced with <code>Vector{T} = Array{T,1}</code> or a <code>const</code> assignment (<a href="https://github.com/JuliaLang/julia/issues/20500">#20500</a>).</p></li><li><p>Experimental feature: <code>x^n</code> for integer literals <code>n</code> (e.g. <code>x^3</code> or <code>x^-3</code>) is now lowered to <code>Base.literal_pow(^, x, Val{n})</code>, to enable compile-time specialization for literal integer exponents (<a href="https://github.com/JuliaLang/julia/issues/20530">#20530</a>, <a href="https://github.com/JuliaLang/julia/issues/20889">#20889</a>).</p></li></ul><h2><a class="nav-anchor" id="Breaking-changes-1" href="#Breaking-changes-1">Breaking changes</a></h2><p>This section lists changes that do not have deprecation warnings.</p><ul><li><p><code>readline</code>, <code>readlines</code> and <code>eachline</code> return lines without line endings by default. You <em>must</em> use <code>readline(s, chomp=false)</code>, etc. to get the old behavior where returned lines include trailing end-of-line character(s) (<a href="https://github.com/JuliaLang/julia/issues/19944">#19944</a>).</p></li><li><p><code>String</code>s no longer have a <code>.data</code> field (as part of a significant performance improvement). Use <code>Vector{UInt8}(str)</code> to access a string as a byte array. However, allocating the <code>Vector</code> object has overhead. You can also use <code>codeunit(str, i)</code> to access the <code>i</code>th byte of a <code>String</code>. Use <code>sizeof(str)</code> instead of <code>length(str.data)</code>, and <code>pointer(str)</code> instead of <code>pointer(str.data)</code> (<a href="https://github.com/JuliaLang/julia/issues/19449">#19449</a>).</p></li><li><p>Operations between <code>Float16</code> and <code>Integers</code> now return <code>Float16</code> instead of <code>Float32</code> (<a href="https://github.com/JuliaLang/julia/issues/17261">#17261</a>).</p></li><li><p>Keyword arguments are processed left-to-right: if the same keyword is specified more than once, the rightmost occurrence takes precedence (<a href="https://github.com/JuliaLang/julia/issues/17785">#17785</a>).</p></li><li><p>The <code>lgamma(z)</code> function now uses a different (more standard) branch cut for <code>real(z) &lt; 0</code>, which differs from <code>log(gamma(z))</code> by multiples of 2π in the imaginary part (<a href="https://github.com/JuliaLang/julia/issues/18330">#18330</a>).</p></li><li><p><code>broadcast</code> now handles tuples, and treats any argument that is not a tuple or an array as a &quot;scalar&quot; (<a href="https://github.com/JuliaLang/julia/issues/16986">#16986</a>).</p></li><li><p><code>broadcast</code> now produces a <code>BitArray</code> instead of <code>Array{Bool}</code> for functions yielding a boolean result.  If you want <code>Array{Bool}</code>, use <code>broadcast!</code> or <code>.=</code> (<a href="https://github.com/JuliaLang/julia/issues/17623">#17623</a>).</p></li><li><p>Operations like <code>.+</code> and <code>.*</code> on <code>Range</code> objects are now generic <code>broadcast</code> calls (see <a href="#language-changes">above</a>) and produce an <code>Array</code>. If you want a <code>Range</code> result, use <code>+</code> and <code>*</code>, etcetera (<a href="https://github.com/JuliaLang/julia/issues/17623">#17623</a>).</p></li><li><p><code>broadcast</code> now treats <code>Ref</code> (except for <code>Ptr</code>) arguments as 0-dimensional arrays (<a href="https://github.com/JuliaLang/julia/issues/18965">#18965</a>).</p></li><li><p><code>broadcast</code> now handles missing data (<code>Nullable</code>s) allowing operations to be lifted over mixtures of <code>Nullable</code>s and scalars, as if the <code>Nullable</code> were like an array with zero or one element (<a href="https://github.com/JuliaLang/julia/issues/16961">#16961</a>, <a href="https://github.com/JuliaLang/julia/issues/19787">#19787</a>).</p></li><li><p>The runtime now enforces when new method definitions can take effect (<a href="https://github.com/JuliaLang/julia/issues/17057">#17057</a>). The flip-side of this is that new method definitions should now reliably actually take effect, and be called when evaluating new code (<a href="https://github.com/JuliaLang/julia/issues/265">#265</a>).</p></li><li><p>The array-scalar methods of <code>/</code>, <code>\</code>, <code>*</code>, <code>+</code>, and <code>-</code> now follow broadcast promotion rules. (Likewise for the now-deprecated array-scalar methods of <code>div</code>, <code>mod</code>, <code>rem</code>, <code>&amp;</code>, <code>|</code>, and <code>xor</code>; see &quot;Deprecated or removed&quot; below.) (<a href="https://github.com/JuliaLang/julia/issues/19692">#19692</a>).</p></li><li><p><code>broadcast!(f, A)</code> now calls <code>f()</code> for each element of <code>A</code>, rather than doing <code>fill!(A, f())</code> (<a href="https://github.com/JuliaLang/julia/issues/19722">#19722</a>).</p></li><li><p><code>rmprocs</code> now throws an exception if requested workers have not been completely removed before <code>waitfor</code> seconds. With a <code>waitfor=0</code>, <code>rmprocs</code> returns immediately without waiting for worker exits.</p></li><li><p><code>quadgk</code> has been moved from Base into a separate package (<a href="https://github.com/JuliaLang/julia/issues/19741">#19741</a>).</p></li><li><p>The <code>Collections</code> module has been removed, and all functions defined therein have been moved to the <code>DataStructures</code> package (<a href="https://github.com/JuliaLang/julia/issues/19800">#19800</a>).</p></li><li><p>The <code>RepString</code> type has been moved to the <a href="https://github.com/JuliaArchive/LegacyStrings.jl">LegacyStrings.jl package</a>.</p></li><li><p>In macro calls with parentheses, e.g. <code>@m(a=1)</code>, assignments are now parsed as <code>=</code> expressions, instead of as <code>kw</code> expressions (<a href="https://github.com/JuliaLang/julia/issues/7669">#7669</a>).</p></li><li><p>When used as an infix operator, <code>~</code> is now parsed as a call to an ordinary operator with assignment precedence, instead of as a macro call (<a href="https://github.com/JuliaLang/julia/issues/20406">#20406</a>).</p></li><li><p>(µ &quot;micro&quot; and ɛ &quot;latin epsilon&quot;) are considered equivalent to the corresponding Greek characters in identifiers.  <code>\varepsilon</code> now tab-completes to U+03B5 (greek small letter epsilon) (<a href="https://github.com/JuliaLang/julia/issues/19464">#19464</a>).</p></li><li><p><code>retry</code> now inputs the keyword arguments <code>delays</code> and <code>check</code> instead of <code>n</code> and <code>max_delay</code>.  The previous functionality can be achieved setting <code>delays</code> to <code>ExponentialBackOff</code> (<a href="https://github.com/JuliaLang/julia/issues/19331">#19331</a>).</p></li><li><p><code>transpose(::AbstractVector)</code> now always returns a <code>RowVector</code> view of the input (which is a  special 1×n-sized <code>AbstractMatrix</code>), not a <code>Matrix</code>, etc. In particular, for  <code>v::AbstractVector</code> we now have <code>(v.&#39;).&#39; === v</code> and <code>v.&#39; * v</code> is a scalar (<a href="https://github.com/JuliaLang/julia/issues/19670">#19670</a>).</p></li><li><p>Parametric types with &quot;unspecified&quot; parameters, such as <code>Array</code>, are now represented as <code>UnionAll</code> types instead of <code>DataType</code>s (<a href="https://github.com/JuliaLang/julia/issues/18457">#18457</a>).</p></li><li><p><code>Union</code> types have two fields, <code>a</code> and <code>b</code>, instead of a single <code>types</code> field. The empty type <code>Union{}</code> is represented by a singleton of type <code>TypeofBottom</code> (<a href="https://github.com/JuliaLang/julia/issues/18457">#18457</a>).</p></li><li><p>The type <code>NTuple{N}</code> now refers to tuples where every element has the same type (since it is shorthand for <code>NTuple{N,T} where T</code>). To get the old behavior of matching any tuple, use <code>NTuple{N,Any}</code> (<a href="https://github.com/JuliaLang/julia/issues/18457">#18457</a>).</p></li><li><p><code>FloatRange</code> has been replaced by <code>StepRangeLen</code>, and the internal representation of <code>LinSpace</code> has changed. Aside from changes in the internal field names, this leads to several differences in behavior (<a href="https://github.com/JuliaLang/julia/issues/18777">#18777</a>):</p><ul><li><p>Both <code>StepRangeLen</code> and <code>LinSpace</code> can represent ranges of arbitrary object types–-they are no longer limited to floating-point numbers.</p></li><li><p>For ranges that produce <code>Float64</code>, <code>Float32</code>, or <code>Float16</code> numbers, <code>StepRangeLen</code> can be used to produce values with little or no roundoff error due to internal arithmetic that is typically twice the precision of the output result.</p></li><li><p>To take advantage of this precision, <code>linspace(start, stop, len)</code> now returns a range of type <code>StepRangeLen</code> rather than <code>LinSpace</code> when <code>start</code> and <code>stop</code> are <code>FloatNN</code>. <code>LinSpace(start, stop, len)</code> always returns a <code>LinSpace</code>.</p></li><li><p><code>StepRangeLen(a, step, len)</code> constructs an ordinary-precision range using the values and types of <code>a</code> and <code>step</code> as given, whereas <code>range(a, step, len)</code> will attempt to match inputs <code>a::FloatNN</code> and <code>step::FloatNN</code> to rationals and construct a <code>StepRangeLen</code> that internally uses twice-precision arithmetic.  These two outcomes exhibit differences in both precision and speed.</p></li></ul></li><li><p><code>A=&gt;B</code> expressions are now parsed as calls instead of using <code>=&gt;</code> as the expression head (<a href="https://github.com/JuliaLang/julia/issues/20327">#20327</a>).</p></li><li><p>The <code>count</code> function no longer sums non-boolean values (<a href="https://github.com/JuliaLang/julia/issues/20404">#20404</a>)</p></li><li><p>Bessel, Hankel, Airy, error, Dawson, eta, zeta, digamma, inverse digamma, trigamma, and polygamma special functions have been moved from Base to the <a href="https://github.com/JuliaMath/SpecialFunctions.jl">SpecialFunctions.jl package</a> (<a href="https://github.com/JuliaLang/julia/issues/20427">#20427</a>).  Note that <code>airy</code>, <code>airyx</code> and <code>airyprime</code> have been deprecated in favor of more specific functions (<code>airyai</code>, <code>airybi</code>, <code>airyaiprime</code>, <code>airybiprimex</code>, <code>airyaix</code>, <code>airybix</code>, <code>airyaiprimex</code>, <code>airybiprimex</code>) (<a href="https://github.com/JuliaLang/julia/issues/18050">#18050</a>).</p></li><li><p><code>write</code> on an <code>IOBuffer</code> now returns a signed integer in order to be consistent with other buffers (<a href="https://github.com/JuliaLang/julia/issues/20609">#20609</a>).</p></li><li><p><code>@async</code>, <code>@spawn</code>, <code>@spawnat</code>, <code>@fetch</code> and <code>@fetchfrom</code> no longer implicitly localize variables. Previously, the expression would be wrapped in an implicit <code>let</code> block  (<a href="https://github.com/JuliaLang/julia/issues/19594">#19594</a>).</p></li><li><p>Closures shipped for remote execution via <code>@spawn</code> or <code>remotecall</code> now automatically serialize globals defined under Main. For details, please refer to the paragraph on &quot;Global variables&quot; under the &quot;Parallel computing&quot; chapter in the manual (<a href="https://github.com/JuliaLang/julia/issues/19594">#19594</a>).</p></li></ul><h2><a class="nav-anchor" id="Library-improvements-1" href="#Library-improvements-1">Library improvements</a></h2><ul><li><p>A new <code>@views</code> macro was added to convert a whole expression or block of code to use views for all slices (<a href="https://github.com/JuliaLang/julia/issues/20164">#20164</a>).</p></li><li><p><code>max</code>, <code>min</code>, and related functions (<code>minmax</code>, <code>maximum</code>, <code>minimum</code>, <code>extrema</code>)  now return <code>NaN</code> for <code>NaN</code> arguments (<a href="https://github.com/JuliaLang/julia/issues/12563">#12563</a>).</p></li><li><p><code>oneunit(x)</code> function to return a dimensionful version of <code>one(x)</code> (which is clarified to mean a dimensionless quantity if <code>x</code> is dimensionful) (<a href="https://github.com/JuliaLang/julia/issues/20268">#20268</a>).</p></li><li><p>The <code>chop</code> and <code>chomp</code> functions now return a <code>SubString</code> (<a href="https://github.com/JuliaLang/julia/issues/18339">#18339</a>).</p></li><li><p>Numbered stackframes printed in stacktraces can now be opened in an editor by entering the corresponding number in the REPL and pressing <code>^Q</code> (<a href="https://github.com/JuliaLang/julia/issues/19680">#19680</a>).</p></li><li><p>The REPL now supports something called <em>prompt pasting</em> (<a href="https://github.com/JuliaLang/julia/issues/17599">#17599</a>). This activates when pasting text that starts with <code>julia&gt; </code> into the REPL. In that case, only expressions starting with <code>julia&gt; </code> are parsed, the rest are removed. This makes it possible to paste a chunk of code that has been copied from a REPL session without having to scrub away prompts and outputs. This can be disabled or enabled at will with <code>Base.REPL.enable_promptpaste(::Bool)</code>.</p></li><li><p>The function <code>print_with_color</code> can now take a color represented by an integer between 0 and 255 inclusive as its first argument (<a href="https://github.com/JuliaLang/julia/issues/18473">#18473</a>). For a number-to-color mapping, please refer to <a href="https://upload.wikimedia.org/wikipedia/commons/1/15/Xterm_256color_chart.svg">this chart</a>. It is also possible to use numbers as colors in environment variables that customizes colors in the REPL. For example, to get orange warning messages, simply set <code>ENV[&quot;JULIA_WARN_COLOR&quot;] = 208</code>. Please note that not all terminals support 256 colors.</p></li><li><p>The function <code>print_with_color</code> no longer prints text in bold by default (<a href="https://github.com/JuliaLang/julia/issues/18628">#18628</a>). Instead, the function now take a keyword argument <code>bold::Bool</code> which determines whether to print in bold or not. On some terminals, printing a color in non bold results in slightly darker colors being printed than when printing in bold. Therefore, light versions of the colors are now supported. For the available colors see the help entry on <code>print_with_color</code>.</p></li><li><p>The default text style for REPL input and answers has been changed from bold to normal (<a href="https://github.com/JuliaLang/julia/issues/11250">#11250</a>). They can be changed back to bold by setting the environment variables <code>JULIA_INPUT_COLOR</code> and <code>JULIA_ANSWER_COLOR</code> to <code>&quot;bold&quot;</code>. For example, one way of doing this is adding <code>ENV[&quot;JULIA_INPUT_COLOR&quot;] = :bold</code> and <code>ENV[&quot;JULIA_ANSWER_COLOR&quot;] = :bold</code> to the <code>.juliarc.jl</code> file. See the <a href="https://docs.julialang.org/en/latest/manual/interacting-with-julia#Customizing-Colors-1">manual section on customizing colors</a> for more information.</p></li><li><p>The default color for info messages has been changed from blue to cyan (<a href="https://github.com/JuliaLang/julia/issues/18442">#18442</a>), and for warning messages from red to yellow (<a href="https://github.com/JuliaLang/julia/issues/18453">#18453</a>).  This can be changed back to the original colors by setting the environment variables <code>JULIA_INFO_COLOR</code> to <code>&quot;blue&quot;</code> and <code>JULIA_WARN_COLOR</code> to <code>&quot;red&quot;</code>.</p></li><li><p>Iteration utilities that wrap iterators and return other iterators (<code>enumerate</code>, <code>zip</code>, <code>rest</code>, <code>countfrom</code>, <code>take</code>, <code>drop</code>, <code>cycle</code>, <code>repeated</code>, <code>product</code>, <code>flatten</code>, <code>partition</code>) have been moved to the module <code>Base.Iterators</code> (<a href="https://github.com/JuliaLang/julia/issues/18839">#18839</a>).</p></li><li><p>BitArrays can now be constructed from arbitrary iterables, in particular from generator expressions, e.g. <code>BitArray(isodd(x) for x = 1:100)</code> (<a href="https://github.com/JuliaLang/julia/issues/19018">#19018</a>).</p></li><li><p><code>hcat</code>, <code>vcat</code>, and <code>hvcat</code> now work with <code>UniformScaling</code> objects, so you can now do e.g. <code>[A I]</code> and it will concatenate an appropriately sized identity matrix (<a href="https://github.com/JuliaLang/julia/issues/19305">#19305</a>).</p></li><li><p>New <code>accumulate</code> and <code>accumulate!</code> functions were added, which generalize <code>cumsum</code> and <code>cumprod</code>. Also known as a <a href="https://en.wikipedia.org/wiki/Prefix_sum">scan</a> operation (<a href="https://github.com/JuliaLang/julia/issues/18931">#18931</a>).</p></li><li><p><code>reshape</code> now allows specifying one dimension with a <code>Colon()</code> (<code>:</code>) for the new shape, in which case that dimension&#39;s length will be computed such that its product with all the other dimensions is equal to the length of the original array (<a href="https://github.com/JuliaLang/julia/issues/19919">#19919</a>).</p></li><li><p>A new <code>titlecase</code> function was added, to capitalize the first character of each word within a string (<a href="https://github.com/JuliaLang/julia/issues/19469">#19469</a>).</p></li><li><p><code>any</code> and <code>all</code> now always short-circuit, and <code>mapreduce</code> never short-circuits (<a href="https://github.com/JuliaLang/julia/issues/19543">#19543</a>). That is, not every member of the input iterable will be visited if a <code>true</code> (in the case of <code>any</code>) or <code>false</code> (in the case of <code>all</code>) value is found, and <code>mapreduce</code> will visit all members of the iterable.</p></li><li><p>Additional methods for <code>ones</code> and <code>zeros</code> functions were added to support the same signature as the <code>similar</code> function (<a href="https://github.com/JuliaLang/julia/issues/19635">#19635</a>).</p></li><li><p><code>count</code> now has a <code>count(itr)</code> method equivalent to <code>count(identity, itr)</code> (<a href="https://github.com/JuliaLang/julia/issues/20403">#20403</a>).</p></li><li><p>Methods for <code>map</code> and <code>filter</code> with <code>Nullable</code> arguments have been implemented; the semantics are as if the <code>Nullable</code> were a container with zero or one elements (<a href="https://github.com/JuliaLang/julia/issues/16961">#16961</a>).</p></li><li><p>New <code>@test_warn</code> and <code>@test_nowarn</code> macros were added in the <code>Base.Test</code> module to test for the presence or absence of warning messages (<a href="https://github.com/JuliaLang/julia/issues/19903">#19903</a>).</p></li><li><p><code>logging</code> can now be used to redirect <code>info</code>, <code>warn</code>, and <code>error</code> messages either universally or on a per-module/function basis (<a href="https://github.com/JuliaLang/julia/issues/16213">#16213</a>).</p></li><li><p>New function <code>Base.invokelatest(f, args...)</code> to call the latest version of a function in circumstances where an older version may be called instead (e.g. in a function calling <code>eval</code>) (<a href="https://github.com/JuliaLang/julia/issues/19784">#19784</a>).</p></li><li><p>A new <code>iszero(x)</code> function was added, to quickly check whether <code>x</code> is zero (or is all zeros, for an array) (<a href="https://github.com/JuliaLang/julia/issues/19950">#19950</a>).</p></li><li><p><code>notify</code> now returns a count of tasks woken up (<a href="https://github.com/JuliaLang/julia/issues/19841">#19841</a>).</p></li><li><p>A new nonstandard string literal <code>raw&quot;...&quot;</code> was added, for creating strings with no interpolation or unescaping (<a href="https://github.com/JuliaLang/julia/issues/19900">#19900</a>).</p></li><li><p>A new <code>Dates.Time</code> type was added that supports representing the time of day with up to nanosecond resolution (<a href="https://github.com/JuliaLang/julia/issues/12274">#12274</a>).</p></li><li><p>A new <code>@macroexpand</code> macro was added as a convenient alternative to the <code>macroexpand</code> function (<a href="https://github.com/JuliaLang/julia/issues/18660">#18660</a>).</p></li><li><p>A new <code>ConjArray</code> type was added, as a wrapper type for lazy complex conjugation of arrays. Currently, it is used by default for the new <code>RowVector</code> type only, and enforces that both <code>transpose(vec)</code> and <code>ctranspose(vec)</code> are views not copies (<a href="https://github.com/JuliaLang/julia/issues/20047">#20047</a>).</p></li><li><p><code>map[!]</code> and <code>broadcast[!]</code> now have dedicated methods for sparse/structured vectors/matrices. Specifically, <code>map[!]</code> and <code>broadcast[!]</code> over combinations including one or more <code>SparseVector</code>, <code>SparseMatrixCSC</code>, <code>Diagonal</code>, <code>Bidiagonal</code>, <code>Tridiagonal</code>, or <code>SymTridiagonal</code>, and any number of <code>broadcast</code> scalars, <code>Vector</code>s, or <code>Matrix</code>s, now efficiently yield <code>SparseVector</code>s or <code>SparseMatrix</code>s as appropriate (<a href="https://github.com/JuliaLang/julia/issues/19239">#19239</a>, <a href="https://github.com/JuliaLang/julia/issues/19371">#19371</a>, <a href="https://github.com/JuliaLang/julia/issues/19518">#19518</a>, <a href="https://github.com/JuliaLang/julia/issues/19438">#19438</a>, <a href="https://github.com/JuliaLang/julia/issues/19690">#19690</a>, <a href="https://github.com/JuliaLang/julia/issues/19724">#19724</a>, <a href="https://github.com/JuliaLang/julia/issues/19926">#19926</a>, <a href="https://github.com/JuliaLang/julia/issues/19934">#19934</a>, <a href="https://github.com/JuliaLang/julia/issues/20009">#20009</a>).</p></li></ul><h2><a class="nav-anchor" id="Compiler/Runtime-improvements-1" href="#Compiler/Runtime-improvements-1">Compiler/Runtime improvements</a></h2><ul><li><p><code>ccall</code> is now implemented as a macro, removing the need for special code-generator support for Intrinsics.</p></li><li><p><code>ccall</code> gained limited support for a <code>llvmcall</code> calling-convention. This can replace many uses of <code>llvmcall</code> with a simpler, shorter declaration.</p></li><li><p>All Intrinsics are now Builtin functions instead and have proper error checking and fall-back static compilation support.</p></li></ul><h2><a class="nav-anchor" id="Deprecated-or-removed-1" href="#Deprecated-or-removed-1">Deprecated or removed</a></h2><ul><li><p>Linear indexing is now only supported when there is exactly one non-cartesian index provided. Allowing a trailing index at dimension <code>d</code> to linearly access the higher dimensions from array <code>A</code> (beyond <code>size(A, d)</code>) has been deprecated as a stricter constraint during bounds checking. Instead, <code>reshape</code> the array such that its dimensionality matches the number of indices (<a href="https://github.com/JuliaLang/julia/issues/20079">#20079</a>).</p></li><li><p><code>isdefined(a::Array, i::Int)</code> has been deprecated in favor of <code>isassigned</code> (<a href="https://github.com/JuliaLang/julia/issues/18346">#18346</a>).</p></li><li><p><code>is</code> has been deprecated in favor of <code>===</code> (which used to be an alias for <code>is</code>) (<a href="https://github.com/JuliaLang/julia/issues/17758">#17758</a>).</p></li><li><p><code>num</code> and <code>den</code> have been deprecated in favor of <code>numerator</code> and <code>denominator</code> respectively (<a href="https://github.com/JuliaLang/julia/issues/19233">#19233</a>).</p></li><li><p>infix operator <code>$</code> has been deprecated in favor of infix <code>⊻</code> or function <code>xor()</code> (<a href="https://github.com/JuliaLang/julia/issues/18977">#18977</a>).</p></li><li><p><code>Dates.recur</code> has been deprecated in favor of <code>filter</code> (<a href="https://github.com/JuliaLang/julia/issues/19288">#19288</a>)</p></li><li><p><code>cummin</code> and <code>cummax</code> have been deprecated in favor of <code>accumulate</code>.</p></li><li><p><code>sumabs</code> and <code>sumabs2</code> have been deprecated in favor of <code>sum(abs, x)</code> and <code>sum(abs2, x)</code>, respectively. <code>maxabs</code> and <code>minabs</code> have similarly been deprecated in favor of <code>maximum(abs, x)</code> and <code>minimum(abs, x)</code>. Likewise for the in-place counterparts of these functions (<a href="https://github.com/JuliaLang/julia/issues/19598">#19598</a>).</p></li><li><p><code>produce</code>, <code>consume</code> and iteration over a Task object have been deprecated in favor of using Channels for inter-task communication  (<a href="https://github.com/JuliaLang/julia/issues/19841">#19841</a>).</p></li><li><p><code>@test_approx_eq x y</code> has been deprecated in favor of <code>@test isapprox(x,y)</code> or <code>@test x ≈ y</code> (<a href="https://github.com/JuliaLang/julia/issues/4615">#4615</a>).</p></li><li><p>Vectorized functions have been deprecated in favor of dot syntax (<a href="https://github.com/JuliaLang/julia/issues/17302">#17302</a>, <a href="https://github.com/JuliaLang/julia/issues/17265">#17265</a>, <a href="https://github.com/JuliaLang/julia/issues/18558">#18558</a>, <a href="https://github.com/JuliaLang/julia/issues/19711">#19711</a>, <a href="https://github.com/JuliaLang/julia/issues/19712">#19712</a>, <a href="https://github.com/JuliaLang/julia/issues/19791">#19791</a>, <a href="https://github.com/JuliaLang/julia/issues/19802">#19802</a>, <a href="https://github.com/JuliaLang/julia/issues/19931">#19931</a>, <a href="https://github.com/JuliaLang/julia/issues/20543">#20543</a>, <a href="https://github.com/JuliaLang/julia/issues/20228">#20228</a>).</p></li><li><p>The two-argument forms of <code>map</code> (<code>map!(f, A)</code>) and <code>asyncmap!</code> (<code>asyncmap!(f, A)</code>) have been deprecated in anticipation of future semantic changes (<a href="https://github.com/JuliaLang/julia/issues/19721">#19721</a>).</p></li><li><p><code>isimag</code> has been deprecated (<a href="https://github.com/JuliaLang/julia/issues/19949">#19949</a>).</p></li><li><p><code>broadcast_zpreserving</code> has been deprecated (<a href="https://github.com/JuliaLang/julia/issues/19533">#19533</a>, <a href="https://github.com/JuliaLang/julia/issues/19720">#19720</a>).</p></li><li><p><code>convert</code> methods from <code>Diagonal</code> and <code>Bidiagonal</code> to subtypes of <code>AbstractTriangular</code> have been deprecated (<a href="https://github.com/JuliaLang/julia/issues/17723">#17723</a>).</p></li><li><p>The zero-argument constructor <code>MersenneTwister()</code> has been deprecated in favor of the explicit <code>MersenneTwister(0)</code> (<a href="https://github.com/JuliaLang/julia/issues/16984">#16984</a>).</p></li></ul><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="manual/introduction.html"><span class="direction">Next</span><span class="title">Introduction</span></a></footer></article></body></html>
